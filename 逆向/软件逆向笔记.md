# 软件逆向笔记

## 1、软件汇编指令比较

```tex
cmp a,b  //比较a与b
mov a,b  //把b值送给a，使a=b
ret      //返回主程序
nop      //无作用
call     //调用子程序，子程序以ret结尾
je或jz   //相等则跳（机器码是74或84）
jne或jnz //不相等则跳（机器码是75或85）
jmp      //无条件跳
jb       //若小于则跳
ja       //若大于则跳
jg       //若大于则跳
jge      //若大于等于则跳
jl       //若小于则跳
pop xxx  //xxx出栈
push xxx  //xxx压栈
```

## 2、字符串

```tex
Unregister   ---  未注册
Trial  -----------  试用
success  ------   成功
unreg  ---------  未校准
```

## 3、按钮事件查找

```tex
C++的按钮事件采用查找SUB EAX,0A
DELPHI的按钮事件查找二进制字符串740E8BD38B83????????FF93????????,每一个都需下断点
易语言按钮事件特征码：FF 55 FC 5F 5E
VC8的按钮事件采用查找SUB EAX,0A
VB的按钮事件查找二进制字符串816C2404??000000
(注：识别VB和P-code编译时，只要找不到按钮事件就是P-code编译)
```

## 4、网站文章

>#### * [x64dbg使用技巧与实用插件合集](https://bbs.pediy.com/thread-266488.htm#msg_header_h2_19) 
>
>#### * [x64官网](https://x64dbg.com/)  
>
>#### *  [Baymax Patch Tools v2.9.5.4/x64 v2.5.4（06月08号更新）](https://bbs.pediy.com/thread-249468.htm) 
>
>* [【五一礼物】StudyPE+ v1.11 出炉](https://www.chinapyg.com/thread-137051-1-1.html) 

## 5、x64dbg快捷键

>| 快捷键     | 功能                                                         |
>| ---------- | ------------------------------------------------------------ |
>| F2         | 在光标处设置或取消**断点**                                   |
>| Ctrl + F2  | **重新启动**被调试程序                                       |
>| F4         | **运行到所选指令处**,如果选择的指令不被执行，则被调试程序一直运行下去 |
>| F7         | 单步**步进**，遇到 call 等子程序时进入其中                   |
>| Shift + F7 | **单步步进**，但当被调试程序发生异常时，调试器尝试步入被调试程序指定的异常处理 |
>| Ctrl + F7  | **自动步进**，在所有的函数调用中一条一条地执行命令           |
>| F8         | **单步步过**，遇到 call 等子程序时不进入其中                 |
>| Shift + F8 | **单步步过**，但当被调试程序发生异常时，调试器尝试步入被调试程序指定的异常处理 |
>| Ctrl + F8  | **自动步过**，在所有的函数调用中一条一条地执行命令           |
>| F9         | **运行，直到遇到下一个断点**                                 |
>| Shift + F9 | 运行到断点，但当被调试程序发生异常时，调试器尝试步入被调试程序指定的异常处理 |
>| Ctrl + F9  | **执行到返回**，在执行到一个 ret 指令时暂停，常用于从当前函数快速返回到上一个函数 |
>| Alt + F9   | **执行到用户代码**，可用于从系统部分快速返回到被调试程序部分 |
>| F12        | **停止执行**，暂停所有线程，可用于暂停自动执行               |
>| ;          | 添加注释                                                     |
>| :          | 添加标签                                                     |
>| –          | **回退上一条指令的位置**                                     |
>| +          | **执行下一条指令**                                           |

## 6、寄存器

>## **通用寄存器** 

AX(AH、AL)：累加器。有些指令约定以AX(或AL)为源或目的寄存器。输入/输出指令必须通过AX或AL实现，例如：端口地址为43H的内容读入CPU的指令为INAL，43H或INAX，43H。目的操作数只能是AL/AX，而不能是其他的寄存器。

BX(BH、BL)：基址寄存器。BX可用作间接寻址的[地址寄存器](https://www.eefocus.com/baike/502627)和基地址寄存器，BH、BL可用作8位通用[数据寄存器](https://www.eefocus.com/baike/496825)。

CX(CH、CL)：计数寄存器。CX在循环和串操作中充当计数器，指令执行后CX内容自动修改，因此称为计数寄存器。

DX(DH、DL)：数据寄存器。除用作通用寄存器外，在I/O指令中可用作端口地址寄存器，乘除指令中用作辅助累加器。 

>## 指针和变址寄存器

BP( Base Pointer regilter)：基址指针寄存器。

SP( Stack Pointer Register)：[堆栈指针](https://www.eefocus.com/baike/499733)寄存器。

SI( Source Index register)：源变址寄存器。

DI( Destination Index Register)：目的变址寄存器。

这组寄存器存放的内容是某一段内地址偏移量，用来形成操作数地址，主要在堆栈操作和变址运算中使用。BP和SP寄存器称为指针寄存器，与SS联用，为访问现行堆栈段提供方便。通常BP寄存器在间接寻址中使用，操作数在堆栈段中，由SS段寄存器与BP组合形成操作数地址即BP中存放现行堆栈段中一个数据区的“基址”的偏移量，所以称BP寄存器为基址指针。

SP寄存器在堆栈操作中使用，PUSH和POP指令是从SP寄存器得到现行堆栈段的段内地址偏移量，所以称SP寄存器为堆栈指针，SP始终指向栈顶。

寄存器SI和DI称为变址寄存器，通常与DS一起使用，为访问现行数据段提供段内地址偏移量。在串指令中，其中源操作数的偏移量存放在SⅠ中，目的操作数的偏移量存放在DI中，SI和DI的作用不能互换，否则传送地址相反。在串指令中，SI、DI均为隐含寻址，此时，SI和DS联用，Dl和ES联用。

>## 段寄存器

8086/8088CPU可直接寻址1MB的存储器空间，直接寻址需要20位地址码，而所有内部寄存器都是16位的，只能直接寻址6KB，因此采用分段技术来解决。将1MB的存储空间分成若干逻辑段，每段最长64KB，这些逻辑段在整个存储空间中可浮动。 

8086/8088CPU内部设置了4个16位段寄存器，它们分别是代码段寄存器CS、数据段寄存器DS、堆栈段寄存器SS、附加段寄存器ES、由它们给出相应逻辑段的首地址，称为“段基址”。段基址与段内偏移地址组合形成20位物理地址，段内偏移地址可以存放在寄存器中，也可以存放在存储器中。

例如：代码段寄存器CS存放当前代码段基地址，IP指令指针寄存器存放了下一条要执行指令的段内偏移地址，其中CS=2000H，IP=001AH。通过组合，形成20位存储单元的寻址地址为2001AH。

代码段内存放可执行的指令代码，数据段和附加段内存放操作的数据，通常操作数在现行数据段中，而在串指令中，目的操作数指明必须在现行附加段中。堆栈段开辟为程序执行中所要用的堆栈区，采用先进后出的方式访问它。各个段寄存器指明了一个规定的现行段，各段寄存器不可互换使用。程序较小时，代码段、数据段、堆栈段可放在一个段内，即包含在64KB之内，而当程序或数据量较大时，超过了64KB，那么可以定义多个代码段或数据段、堆栈段、附加段。现行段由段寄存器指明段地址，使用中可以修改段寄存器内容，指向其他段。有时为了明确起见，可在指令前加上段超越的前缀，以指定操作数所在段。 

>## **指令指针寄存器IP**  

8086/8088CPU中设置了一个16位指令指针寄存器IP，用来存放将要执行的下一条指令在现行代码段中的偏移地址。程序运行中，它由BIU自动修改，使IP始终指向下一条将要执行的指令的地址，因此它是用来控制指令序列的执行流程的，是一个重要的寄存器。8086程序不能直接访问IP，但可以通过某些指令修改IP的内容。例如，当遇到中断指令或调用[子程序](https://www.eefocus.com/baike/499965)指令时，8086自动调整IP的内容，将IP中下一条将要执行的指令地址偏移量入栈保护，待中断程序执行完毕或子程序返回时，可将保护的内容从堆栈中弹出到IP，使[主程序](https://www.eefocus.com/baike/499963)继续运行。在跳转指令时，则将新的跳转目标地址送入IP，改变它的内容，实现了程序的转移。

>## **标志寄存器FR** 

标志寄存器FR也称程序状态字寄存器。 

FR是16位寄存器，其中有9位有效位用来存放状态标志和控制标志。状态标志共6位，CF、PF、AF、ZF、SF和OF，用于寄存程序运行的状态信息，这些标志往往用作后续指令判断的依据。控制标志有3位，IF、DF和TF，用于控制CPU的操作，是人为设置的。

>## **寄存器的工作原理** 

在计算机及其他计算系统中，寄存器是一种非常重要的、必不可少的数字电路苛件，它通常由[触发器](https://www.eefocus.com/baike/481032)（[D触发器](https://www.eefocus.com/baike/502628)）组成，主要作用是用来暂时存放数码或指令。一个触发器司以存放一位二进制代码，若要存放N位二进制数码，则需用N个触发器。 

寄存器应具有接收数据、存放数据和输出数据的功能，它由触发器和门电路组成。只有得到“存入脉冲”（又称“存入指令”、“写入指令”）时，寄存器才能接收数据；在得到“读出”指令时，寄存器才将数据输出。 

寄存器存放数码的方式有并行和串行两种。并行方式是数码从各对应位输入端同时输入到寄存器中；串行方式是数码从一个输入端逐位输入到寄存器中。

寄存器读出数码的方式也有并行和串行两种。在并行方式中，被读出的数码同时出现在各位的输出端上；在串行方式中，被读出的数码在一个输出端逐位出现。

![寄存器](C:\Users\Administrator\Documents\我的文件\笔记\img\寄存器.png) 

## 7、**常用的5种编程语言入口（OEP）特征** 

>## 1、**Borland Delphi** 
>
>![**Borland Delphi**](images\Borland Delphi.png) 
>
>## 2、**Microsoft Visual C++ 6.0** 
>
>![**Microsoft Visual C++ 6.0**](images\Microsoft Visual C++ 6.0.png) 
>
>## 3、**Microsoft Visual Basic 5.0 / 6.0** 
>
>![**Microsoft Visual Basic 5.0 / 6.0**](images\Microsoft Visual Basic 5.0  6.0.png) 
>
>## 4、**MASM32 / TASM32** 
>
>![**MASM32 / TASM32**](images\MASM32 & TASM32.png) 
>
>## 5、**易语言独立编译** 
>
>![**易语言独立编译**](images\易语言独立编译.png) 
>
>## 6、**Borland C++ 1999（BC++6）** 
>
>![**Borland C++ 1999（BC++6）**](images\Borland C++ 1999（BC++6）.png) 
>
>## 7、**Borland C++ 1999（BC++2010）感觉跟BC++6一样** 
>
>![**Borland C++ 1999（BC++2010)**](images\Borland C++ 1999（BC++2010）感觉跟BC++6一样.png)
>
>## 8、**Microsoft Visual C++ 8 \*（VS2008）** 
>
>![**Microsoft Visual C++ 8 \*（VS2008）**](images\Microsoft Visual C++ 8 （VS2008）.png)  
>
>## 9、**Microsoft Visual C++ 8 \*（VS2013）** 
>
>![**Microsoft Visual C++ 8 \*（VS2013）**](images\Microsoft Visual C++ 8 （VS2013）.png)
>
>## 10、**易语言非独立编译** 
>
>![**易语言非独立编译**](images\易语言非独立编译.png)  
>
>## 11、**QT5.4** 
>
>![**QT5.4**](images\QT5.4.png) 
>
>## 12、**PB** 
>
>![**PB**](images\PB.png) 
>
>## 12、**AutoIt_v3** 
>
>![**AutoIt_v3**](images\AutoIt_v3.png) 
